{"version":3,"sources":["App.js","reportWebVitals.js","index.js"],"names":["sqr","x","dist2","v","w","y","App","useState","currentMousePosition","setCurrentMousePosition","linePoints","setLinePoints","positions","setPositions","polylines","setPolylines","ref","useRef","useEventListener","event","keyCode","useAnimationFrame","current","canvas","context","getContext","clearRect","width","height","drawLines","loopPositions","beginPath","moveTo","lineTo","stroke","forEach","polyline","lastPosition","pop","handleClick","useCallback","points","length","handleMouseMove","position","clientX","clientY","pastPositions","flat","slice","shortDistances","distances","pos","push","line","p","l2","distance","t","Math","max","min","sqrt","distToSegment","filter","newSnapPosition","sort","a","b","window","innerWidth","innerHeight","style","backgroundColor","onClick","onMouseMove","console","log","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4639e2f0.chunk.js","sourcesContent":["import { useCallback, useState, useRef } from 'react';\nimport useAnimationFrame from 'use-animation-frame';\nimport useEventListener from '@use-it/event-listener';\n\n// Styles\nimport './App.css';\n\n// by this person: https://stackoverflow.com/a/1501725/4307769\nfunction sqr(x) {\n    return x * x;\n}\n\nfunction dist2(v, w) {\n    return sqr(v.x - w.x) + sqr(v.y - w.y);\n}\n\nfunction distToSegment(p, v, w) {\n    const l2 = dist2(v, w);\n    if (l2 === 0) {\n        return {\n            distance: dist2(p, v),\n            x: v.x,\n            y: v.y,\n        };\n    }\n\n    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\n    t = Math.max(0, Math.min(1, t));\n\n    const x = v.x + t * (w.x - v.x);\n    const y =v.y + t * (w.y - v.y);\n    return {\n        distance: Math.sqrt(dist2(p, { x, y })),\n        x,\n        y,\n    };\n}\n\nfunction App() {\n    // set mouse position - could use a debounce to improve performance\n    const [currentMousePosition, setCurrentMousePosition] = useState({});\n\n    // set the last formed line points\n    const [linePoints, setLinePoints] = useState([]);\n\n    // set all \"unfinished\" positions (no esc pressed)\n    const [positions, setPositions] = useState([]);\n\n    // set all the \"saved\" positions\n    const [polylines, setPolylines] = useState([]);\n\n    // reference for the canvas\n    const ref = useRef(null);\n\n    // distance to trigger the snap\n    const snapDistance = 30;\n\n    // listener for the esc key\n    // since we already have all the state in a hook variable\n    // we can easily implement control + z feature\n    useEventListener('keydown', (event) => {\n        if (event.keyCode === 27) {\n            setPolylines([\n                ...polylines,\n                positions,\n            ]);\n            setPositions([]);\n            setLinePoints([]);\n        }\n    });\n\n    // let's update the canvas on every animation frame update\n    // we need this to re-draw the line preview that follows the mouse point\n    useAnimationFrame(() => {\n        if (!ref.current) {\n            return;\n        }\n\n        const canvas = ref.current;\n        const context = canvas.getContext('2d');\n\n        // clear the canvas\n        context.clearRect(0, 0, canvas.width, canvas.height);\n\n        // helper function to draw the lines on the canvas\n        const drawLines = (loopPositions) => {\n            context.beginPath();\n            context.moveTo(loopPositions[0].x, loopPositions[0].y);\n            context.lineTo(loopPositions[1].x, loopPositions[1].y);\n            context.stroke();\n        }\n\n        // draw lines for all saved positions\n        polylines.forEach((polyline) => {\n            polyline.forEach(drawLines);\n        });\n\n        // draw lines for all un-saved positions\n        positions.forEach(drawLines);\n\n        // draw line for the preview\n        const lastPosition = [...linePoints].pop() || {};\n        if (lastPosition.x && lastPosition.y && currentMousePosition.x && currentMousePosition.y) {\n            context.beginPath();\n            context.moveTo(lastPosition.x, lastPosition.y);\n            context.lineTo(currentMousePosition.x, currentMousePosition.y);\n            context.stroke();\n        }\n    }, [positions, ref.current, currentMousePosition, linePoints]);\n\n    const handleClick = useCallback(() => {\n        const points = [\n            ...linePoints,\n            currentMousePosition\n        ];\n\n        if (points.length === 2) {\n            setPositions([\n                ...positions,\n                points\n            ])\n            setLinePoints([currentMousePosition]);\n        } else {\n            setLinePoints(points);\n        }\n    }, [positions, currentMousePosition, linePoints]);\n\n    const handleMouseMove = useCallback((event) => {\n        const position = {\n            x: event.clientX,\n            y: event.clientY,\n        };\n\n        const pastPositions = [\n            ...polylines.flat(),\n            ...positions.slice(0, -1)\n        ];\n\n        let shortDistances =[];\n        // if we have some positions set, then let's try to find\n        // the nearest position within the \"snapDistance\" range\n        // this can be heavily improved I fear\n        if (pastPositions.length) {\n            const distances = [];\n            pastPositions.forEach((pos) => {\n                distances.push({\n                    line: pos,\n                    ...distToSegment(position, pos[0], pos[1]),\n                });\n            });\n\n            shortDistances = distances.filter((distance) => {\n                return distance.distance < snapDistance;\n            });\n        }\n\n        // get the closest one\n        const newSnapPosition = shortDistances.sort((a, b) => b.distance - a.distance);\n        if (newSnapPosition.length) {\n            setCurrentMousePosition({\n                x: newSnapPosition[0].x,\n                y: newSnapPosition[0].y,\n            });\n        } else {\n            // if we don't have it, just set to the current mouse position\n            setCurrentMousePosition(position);\n        }\n    }, [polylines, positions]);\n\n    return (\n        <div>\n            <canvas\n                ref={ref}\n                width={window.innerWidth}\n                height={window.innerHeight}\n                style={{\n                    backgroundColor: '#ddd',\n                }}\n                onClick={handleClick}\n                onMouseMove={handleMouseMove}\n            />\n            <button\n                onClick={() => console.log({\n                    currentMousePosition,\n                    linePoints,\n                    positions,\n                    polylines,\n                })}\n            >\n                clicky\n            </button>\n        </div>\n    );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}